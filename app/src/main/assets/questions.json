[
  {
    "id": 1,
    "title": "关于多线程并行处理定时任务的情况，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "推荐使用Timer方式处理。",
        "result": false
      },
      {
        "title": "推荐使用ScheduledExecutorService方式处理。",
        "result": true
      },
      {
        "title": "Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行。",
        "result": true
      },
      {
        "title": "ScheduledExecutorService并发运行多个定时任务时，其中某线程抛出异常，不会影响到其它线程的继续运行。",
        "result": true
      }
    ]
  },
  {
    "id": 2,
    "title": "在多线程并发读写的情况下，下列哪些处理方式能保证对象的线程安全",
    "multi": true,
    "choose": [
      {
        "title": "使用volatile关键字。",
        "result": false
      },
      {
        "title": "使用synchronized关键字给对象的读写操作加锁。",
        "result": true
      },
      {
        "title": "如果是基本类型，推荐使用java.util.concurrent.atomic包下面提供的线程安全的基本类型包装类，例如AtomicInteger。",
        "result": true
      },
      {
        "title": "如果是集合，推荐使用java.util.concurrent提供的并发集合类，例如：ConcurrentHashMap。",
        "result": true
      }
    ]
  },
  {
    "id": 3,
    "title": "关于线程池管理线程的好处，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "能够减少在创建和销毁线程上所花的时间以及系统资源的开销。",
        "result": true
      },
      {
        "title": "使用线程池一定能避免OOM问题。",
        "result": false
      },
      {
        "title": "线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。",
        "result": true
      },
      {
        "title": "线程池能够根据资源等待情况，自动调整线程优先级并解决死锁问题。",
        "result": false
      }
    ]
  },
  {
    "id": 4,
    "title": "关于加锁，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "可以只锁代码区块的情况下，就不要锁整个方法体。",
        "result": true
      },
      {
        "title": "高并发的业务场景下，要考虑加锁及同步处理带来的性能损耗，能用无锁数据结构，就不要用锁。",
        "result": true
      },
      {
        "title": "能用对象锁的情况下，就不要用类锁。",
        "result": true
      },
      {
        "title": "加锁时需要保持一致的加锁顺序，否则可能会造成死锁。",
        "result": true
      }
    ]
  },
  {
    "id": 5,
    "title": "关于数据库中表相关的命名，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "表名、字段名禁止出现数字开头，禁止两个下划线中间只出现数字。",
        "result": true
      },
      {
        "title": "表名不使用复数名词。",
        "result": true
      },
      {
        "title": "表必备三字段命名：id, gmt_create, gmt_modify。",
        "result": false
      },
      {
        "title": "表必备三字段命名：id, gmt_create, gmt_modified。",
        "result": true
      }
    ]
  },
  {
    "id": 6,
    "title": "关于使用explain对数据库性能进行优化分析，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": false,
    "choose": [
      {
        "title": "SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。",
        "result": true
      },
      {
        "title": "index级别走的是扫描索引，所以速度会比ref快。",
        "result": false
      },
      {
        "title": "range级别是指对表进行范围索引。",
        "result": false
      },
      {
        "title": "ref级别是指使用主键或者唯一索引。",
        "result": false
      }
    ]
  },
  {
    "id": 7,
    "title": "关于索引效率，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "使用索引的效率一定高于全表扫描的效率。",
        "result": false
      },
      {
        "title": "关于explain的结果，type=index的索引效率好于type=ref。",
        "result": false
      },
      {
        "title": "sql查询条件 where a like ‘%阿里%’ ，不会走索引。",
        "result": true
      },
      {
        "title": "sql查询条件 where a like ‘阿里%’ ,a列创建了索引，一般会使用索引进行检索。",
        "result": true
      }
    ]
  },
  {
    "id": 8,
    "title": "关于MySQL性能优化的描述，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "主键查询优先于二级索引查询。",
        "result": true
      },
      {
        "title": "表连接有一定的代价，故表连接数量越少越好。",
        "result": true
      },
      {
        "title": "一般情况下，二级索引扫描优先于全表扫描。",
        "result": true
      },
      {
        "title": "可以使用通过索引避免排序代价。",
        "result": true
      }
    ]
  },
  {
    "id": 9,
    "title": "关于索引的设计，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "对varchar类型的字段建立索引，必须指定索引长度。",
        "result": true
      },
      {
        "title": "对varchar类型的字段建立索引，不需要指定索引长度，这样索引区分度最好。",
        "result": false
      },
      {
        "title": "业务上具有唯一特性的字段（含组合字段），必须指定唯一索引。",
        "result": true
      },
      {
        "title": "建复合索引时，一般选择区分度高的字段放在最左列。",
        "result": true
      }
    ]
  },
  {
    "id": 10,
    "title": "KV结构的集合，在处理null值的存储上有细微的区别，下列哪些说法是正确的",
    "multi": false,
    "choose": [
      {
        "title": "TreeMap的key不可以为null",
        "result": true
      },
      {
        "title": "TreeMap的key可以为null",
        "result": false
      },
      {
        "title": "ConcurrentHashMap的key可以为null",
        "result": false
      },
      {
        "title": "ConcurrentHashMap的value可以为null",
        "result": false
      }
    ],
    "tip": "HashMap的key/value均可以为null，但是TreeMap的key不能为空，value可以为空"
  },
  {
    "id": 11,
    "title": "Hashtable，HashMap, ConcurrentHashMap都是Map的实现类，它们在处理null值的存储上有细微的区别，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "Hashtable的KV都不可以为null。",
        "result": true
      },
      {
        "title": "HashMap的KV都可以为null。",
        "result": true
      },
      {
        "title": "HashMap的K不可以为null，V可以为null。",
        "result": false
      },
      {
        "title": "ConcurrentHashMap的KV都不可以为null。",
        "result": true
      }
    ]
  },
  {
    "id": 12,
    "title": "sort表示元素在存入集合时进行了排序，数据遍历的结果是按某个排序规则输出的； 而order表示每次遍历的序列都是一样的，元素前后关系每次遍历都是确定的，那么下列哪些集合既是sort，又是order的",
    "multi": false,
    "choose": [
      {
        "title": "HashSet",
        "result": false
      },
      {
        "title": "LinkedList",
        "result": false
      },
      {
        "title": "HashMap",
        "result": false
      },
      {
        "title": "TreeSet",
        "result": true
      }
    ]
  },
  {
    "id": 13,
    "title": "关于checked/unchecked exception，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "继承java.lang.Error的类属于checked exception。",
        "result": false
      },
      {
        "title": "checked异常继承java.lang.Exception类。",
        "result": true
      },
      {
        "title": "unchecked异常继承java.lang.RuntimeException类。",
        "result": true
      },
      {
        "title": "NullPointerException , IllegalArgumentException属于unchecked exception。",
        "result": true
      }
    ]
  },
  {
    "id": 14,
    "title": "关于接口使用抛异常还是返回错误码，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "向公司外部提供的http/api接口，推荐使用“错误码”方式返回异常或者错误信息。",
        "result": true
      },
      {
        "title": "对于应用内部的方法调用，推荐使用“抛出异常”的方式处理异常或者错误信息。",
        "result": true
      },
      {
        "title": "跨应用的RPC调用，推荐使用将“错误码”和“错误简短信息”封装成Result的方式进行返回。",
        "result": true
      },
      {
        "title": "对外提供的接口，一定要保证逻辑健壮性：尽量避免空指针等技术类异常；对于业务类异常要做好错误码或者异常信息的封装。",
        "result": true
      }
    ]
  },
  {
    "id": 15,
    "title": "关于异常的处理方式，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "为防止obj对象本身空指针异常，书写代码时应该注意加异常捕获处理，例如：try { obj.method() } catch(NullPointerException e){……} 。",
        "result": false
      },
      {
        "title": "方法签名中，抛给调用者的关键字为throws",
        "result": true
      },
      {
        "title": "方法内部，抛出异常实例对象为throws",
        "result": false
      },
      {
        "title": "自定义异常要做到“认知对等”，即：抛出者和接收者要保持对自定义异常的认知统一，接收方需要知道这种异常的含义和对应的处理方案",
        "result": true
      }
    ]
  },
  {
    "id": 16,
    "title": "如何处理单元测试产生的数据，下列哪些说法是正确的？",
    "multi": true,
    "choose": [
      {
        "title": "测试数据入库时加特殊前缀标识。",
        "result": true
      },
      {
        "title": "测试数据使用独立的测试库。",
        "result": true
      },
      {
        "title": "自动回滚单元测试产生的脏数据。",
        "result": true
      },
      {
        "title": "无须区别，统一在业务代码中进行判断和识别。",
        "result": false
      }
    ]
  },
  {
    "id": 17,
    "title": "关于并发处理，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。",
        "result": true
      },
      {
        "title": "同步处理时，能锁部分代码区块的情况下不要锁整个方法；高并发时，同步调用应该考虑到性能损耗。",
        "result": true
      },
      {
        "title": "创建线程或线程池时，推荐给线程指定一个有意义的名称，方便出错时回溯。",
        "result": true
      },
      {
        "title": "推荐使用Executors.newFixedThreadPool(int x)生成指定大小的线程池。(线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式)",
        "result": false
      }
    ]
  },
  {
    "id": 18,
    "title": "下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。",
        "result": true
      },
      {
        "title": "永久弃用的代码段注释掉即可，即不用加任何注释。",
        "result": false
      },
      {
        "title": "对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三 个斜杠(///)来说明注释掉代码的理由。",
        "result": true
      },
      {
        "title": "不要在视图模板中加入任何复杂的逻辑。",
        "result": true
      }
    ]
  },
  {
    "id": 19,
    "title": "关于分页查询，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "分页查询，当统计的count为0时，应该直接返回，不要再执行分页查询语句。",
        "result": true
      },
      {
        "title": "iBATIS自带的queryForList(String statementName,int start,int size)分页接口有性能隐患，不允许使用。",
        "result": true
      },
      {
        "title": "定义明确的sql查询语句，通过传入参数start和size来实现分页逻辑。",
        "result": true
      },
      {
        "title": "可使用存储过程写分页逻辑，提高效率。",
        "result": false
      }
    ]
  },
  {
    "id": 20,
    "title": "根据《阿里巴巴Java开发手册》，以下功能必须进行水平权限控制校验的有",
    "multi": true,
    "choose": [
      {
        "title": "订单详情页面。",
        "result": true
      },
      {
        "title": "类目管理后台。",
        "result": true
      },
      {
        "title": "店铺装修后台。",
        "result": true
      },
      {
        "title": "订单付款页面。",
        "result": true
      }
    ]
  },
  {
    "id": 21,
    "title": "关于数据库中NULL的描述，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "NULL=NULL的返回结果为true",
        "result": false
      },
      {
        "title": "NULL与任何值的比较结果都为NULL。",
        "result": true
      },
      {
        "title": "NULL<>1的返回结果为true。",
        "result": false
      },
      {
        "title": "当某一列的值全是NULL时，sum(col)的返回结果为NULL。",
        "result": true
      }
    ]
  },
  {
    "id": 22,
    "title": "关于接口使用抛异常还是返回错误码，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "向公司外部提供的http/api接口，推荐使用“错误码”方式返回异常或者错误信息。",
        "result": true
      },
      {
        "title": "对于应用内部的方法调用，推荐使用“抛出异常”的方式处理异常或者错误信息。",
        "result": true
      },
      {
        "title": "跨应用的RPC调用，推荐使用将“错误码”和“错误简短信息”封装成Result的方式进行返回。",
        "result": true
      },
      {
        "title": "对外提供的接口，一定要保证逻辑健壮性：尽量避免空指针等技术类异常；对于业务类异常要做好错误码或者异常信息的封装。",
        "result": true
      }
    ]
  },
  {
    "id": 23,
    "title": "关于类的序列化，下列说法哪些是正确的",
    "multi": false,
    "choose": [
      {
        "title": "类的序列化与serialVersionUID毫无关系。",
        "result": false
      },
      {
        "title": "如果完全不兼容升级，不需要修改serialVersionUID值。",
        "result": false
      },
      {
        "title": "POJO类的serialVersionUID不一致会编译出错。",
        "result": false
      },
      {
        "title": "POJO类的serialVersionUID不一致会抛出序列化运行时异常。",
        "result": true
      }
    ]
  },
  {
    "id": 24,
    "title": "关于Java的接口描述，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "在接口类中的方法和属性使用public修饰符。",
        "result": false
      },
      {
        "title": "对于Service类，内部的实现类加Impl的后缀与接口区别。例如：ProductServiceImpl实现ProductService接口。",
        "result": true
      },
      {
        "title": "对于Service类，基于SOA的理念，是以接口方式暴露服务。",
        "result": true
      },
      {
        "title": "尽量不在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，而且是整个应用的基础常量。",
        "result": true
      }
    ]
  },
  {
    "id": 25,
    "title": "集合在遍历过程中，有时需要对符合一定条件的元素进行删除，下列哪些说法是正确的",
    "multi": false,
    "choose": [
      {
        "title": "在 foreach 循环里进行元素的 remove操作。",
        "result": false
      },
      {
        "title": "使用Iterator方式，如果有并发，需要对Iterator对象加锁。",
        "result": true
      },
      {
        "title": "Iterator进行元素的删除操作，绝对是线程安全的。",
        "result": false
      },
      {
        "title": "Java无法实现在遍历时，进行删除元素操作。",
        "result": false
      }
    ]
  },
  {
    "id": 26,
    "title": "关于基本数据类型与包装数据类型的使用标准，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "所有的POJO类属性必须使用包装数据类型。",
        "result": true
      },
      {
        "title": "RPC方法的返回值和参数必须使用包装数据类型。",
        "result": true
      },
      {
        "title": "因为JAVA的自动装箱与拆箱机制，不需要根据场景来区分数据类型。",
        "result": false
      },
      {
        "title": "所有的局部变量推荐使用基本数据类型。",
        "result": true
      }
    ]
  },
  {
    "id": 27,
    "title": "关于索引的设计，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "对varchar类型的字段建立索引，必须指定索引长度。",
        "result": true
      },
      {
        "title": "对varchar类型的字段建立索引，不需要指定索引长度，这样索引区分度最好。",
        "result": false
      },
      {
        "title": "业务上具有唯一特性的字段（含组合字段），必须指定唯一索引。",
        "result": true
      },
      {
        "title": "建复合索引时，一般选择区分度高的字段放在最左列。",
        "result": true
      }
    ]
  },
  {
    "id": 28,
    "title": "关于二方库版本号的命名方式，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "版本号命名格式：主版本号.次版本号.修订号。",
        "result": true
      },
      {
        "title": "主版本号:产品方向改变，或者大规模API不兼容，或者架构不兼容升级。",
        "result": true
      },
      {
        "title": "次版本号:保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。",
        "result": true
      },
      {
        "title": "修订号:保持完全兼容性，修复BUG、新增次要功能特性等。",
        "result": true
      }
    ]
  },
  {
    "id": 29,
    "title": "关于索引的使用，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "查询语句 WHERE a+1 = 5 可以利用a索引。",
        "result": false
      },
      {
        "title": "查询语句WHERE date_format(gmt_create, '%Y-%m-%d') = '2016-11-11'无法利用gmt_create索引。",
        "result": true
      },
      {
        "title": "当 c 列类型为 char 时，查询语句 WHERE c = 5 无法利用c索引。",
        "result": true
      },
      {
        "title": "索引字段使用时不能进行函数运算。",
        "result": true
      }
    ]
  },
  {
    "id": 30,
    "title": "关于生产环境的日志文件，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "异常信息应该包括两类信息：案发现场信息和异常堆栈信息。",
        "result": true
      },
      {
        "title": "日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。",
        "result": true
      },
      {
        "title": "避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false。",
        "result": true
      },
      {
        "title": "错误日志和业务日志尽量分开存放。",
        "result": true
      }
    ]
  },
  {
    "id": 31,
    "title": "关于代码注释，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "特殊注释标记，请注明标记人与标记时间。",
        "result": true
      },
      {
        "title": "待办事宜（TODO）:（ [标记人，标记时间，[预计处理时间]）",
        "result": true
      },
      {
        "title": "在注释中用FIXME标记某代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进",
        "result": false
      },
      {
        "title": "在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况",
        "result": true
      }
    ]
  },
  {
    "id": 32,
    "title": "关于MySQL性能优化的描述，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "主键查询优先于二级索引查询。",
        "result": true
      },
      {
        "title": "表连接有一定的代价，故表连接数量越少越好。",
        "result": true
      },
      {
        "title": "一般情况下，二级索引扫描优先于全表扫描。",
        "result": true
      },
      {
        "title": "可以使用通过索引避免排序代价。",
        "result": true
      }
    ]
  },
  {
    "id": 33,
    "title": "关于索引的设计和使用，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "若查询条件中不包含索引的最左列，则无法使用索引。",
        "result": true
      },
      {
        "title": "对于范围查询，只能利用索引的最左列。",
        "result": false
      },
      {
        "title": "对于order by A或group by A语句，在A上建立索引，可以避免排序。",
        "result": false
      },
      {
        "title": "对于多列排序，需要所有所有列排序方向一致，才能利用索引。",
        "result": true
      }
    ]
  },
  {
    "id": 34,
    "title": "关于类命名，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "抽象类命名使用Abstract或Base开头。",
        "result": true
      },
      {
        "title": "异常类命名使用Exception结尾。",
        "result": true
      },
      {
        "title": "测试类命名以它要测试的类的名称开始，以Test结尾。",
        "result": true
      },
      {
        "title": "如果使用到了设计模式，建议在类名中体现出具体模式。例如代理模式的类命名：LoginProxy；观察者模式命名：ResourceObserver。",
        "result": true
      }
    ]
  },
  {
    "id": 35,
    "title": "关于数据库模糊检索的描述，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "绝对禁止左模糊。",
        "result": true
      },
      {
        "title": "绝对禁止全模糊。",
        "result": true
      },
      {
        "title": "绝对禁止右模糊。",
        "result": false
      },
      {
        "title": "全模糊或左模糊查询需求，优先使用搜索引擎。",
        "result": true
      }
    ]
  },
  {
    "id": 36,
    "title": "关于代码注释，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "所有的抽象方法（包括接口中的方法）必须要用javadoc注释。",
        "result": true
      },
      {
        "title": "所有的方法，包括私有方法，最好都增加注释，有总比没有强。",
        "result": false
      },
      {
        "title": "过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。",
        "result": true
      },
      {
        "title": "我的命名和代码结构非常好，可以减少注释的内容。",
        "result": true
      }
    ]
  },
  {
    "id": 37,
    "title": "关于checked/unchecked exception，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "继承java.lang.Error的类属于checked exception。",
        "result": false
      },
      {
        "title": "checked异常继承java.lang.Exception类。",
        "result": true
      },
      {
        "title": "unchecked异常继承java.lang.RuntimeException类。",
        "result": true
      },
      {
        "title": "NullPointerException , IllegalArgumentException属于unchecked exception。",
        "result": true
      }
    ]
  },
  {
    "id": 38,
    "title": "关于Map类型集合的遍历方式，下列哪些说法是正确的",
    "multi": false,
    "choose": [
      {
        "title": "Map类型的实现类都同时实现了Iterator接口。",
        "result": false
      },
      {
        "title": "使用foreach进行遍历。",
        "result": false
      },
      {
        "title": "推荐使用keySet进行遍历。",
        "result": false
      },
      {
        "title": "推荐使用entrySet进行遍历。",
        "result": true
      }
    ]
  },
  {
    "id": 39,
    "title": "关于变量、方法名、包的命名，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "POJO类中的任何布尔类型的变量，都不要加is，因为部分框架解析时有可能会出现序列化错误。",
        "result": true
      },
      {
        "title": "包名统一使用单数形式，如：com.alibaba.mpp.util。",
        "result": true
      },
      {
        "title": "中括号是数组类型的一部分，数组定义如下：String[] args; 不要误写为String args[]；",
        "result": true
      },
      {
        "title": "Service/DAO层方法命名可以参考规约，例如：删除的方法推荐使用remove或delete做前缀。",
        "result": true
      }
    ]
  },
  {
    "id": 40,
    "title": "关于常量定义，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "不允许出现任何魔法值（即未经预先定义的常量）直接出现在代码中。",
        "result": true
      },
      {
        "title": "魔法值是指程序中随意定义并赋值的变量值，如果代码编写者明白变量值意义是可以任意使用的，例如在代码中写if(status == 3) return error;符合规范。",
        "result": false
      },
      {
        "title": "如果变量值仅在一个范围内变化推荐用Enum类。",
        "result": true
      },
      {
        "title": "在程序中，一律禁止使用枚举类型。",
        "result": false
      }
    ]
  },
  {
    "id": 41,
    "title": "关于maven依赖、仲裁、规则，下列哪些说法是正确的：",
    "multi": true,
    "choose": [
      {
        "title": "<dependencies>的依赖会默认传递给子项目。",
        "result": true
      },
      {
        "title": "<dependencies>的依赖绝对不会传递给子项目。",
        "result": false
      },
      {
        "title": "在<dependencyManagement>中指定版本号。",
        "result": true
      },
      {
        "title": "避免在不同的子项目，声明同一个二方库的不同版本号。",
        "result": true
      }
    ]
  },
  {
    "id": 42,
    "title": "关于二方库升级，下列哪些说法是正确的",
    "multi": false,
    "choose": [
      {
        "title": "升级二方库只是改个版本号，不需要关联功能的回归。",
        "result": false
      },
      {
        "title": "升级二方库需要比对仲裁结果的差异，谨慎评估。",
        "result": true
      },
      {
        "title": "升级二方库，绝对不会影响到其它二方库的版本号。",
        "result": false
      },
      {
        "title": "只要此二方库负责人保证说不会有任何影响，即可大胆升级，直接发布上线。",
        "result": false
      }
    ]
  },
  {
    "id": 43,
    "title": "关于表字段和索引，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "表字段注释，如果修改字段含义或对字段表示的状态追加时，需要及时更新。",
        "result": true
      },
      {
        "title": "合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。",
        "result": true
      },
      {
        "title": "针对表的每个字段都增加索引，加快查询速度。",
        "result": false
      },
      {
        "title": "字段的区分度越高，索引的查找速度越快。",
        "result": true
      }
    ]
  },
  {
    "id": 44,
    "title": "关于测试代码的覆盖率，下列哪些说法是正确的？",
    "multi": false,
    "choose": [
      {
        "title": "路径覆盖是最强覆盖，符合路径覆盖且测试全部通过，程序绝对没有问题。",
        "result": false
      },
      {
        "title": "语句覆盖度是最弱的覆盖度量方式。",
        "result": true
      },
      {
        "title": "分支覆盖与条件覆盖其实是一回事。",
        "result": false
      },
      {
        "title": "判定条件覆盖与路径覆盖其实是一回事。",
        "result": false
      }
    ]
  },
  {
    "id": 45,
    "title": "Hashtable，HashMap, ConcurrentHashMap都是Map的实现类，它们在处理null值的存储上有细微的区别，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "Hashtable的KV都不可以为null。",
        "result": true
      },
      {
        "title": "HashMap的KV都可以为null。",
        "result": true
      },
      {
        "title": "HashMap的K不可以为null，V可以为null。",
        "result": false
      },
      {
        "title": "ConcurrentHashMap的KV都不可以为null。",
        "result": true
      }
    ]
  },
  {
    "id": 46,
    "title": "关于数据库命名规则，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "数据库库名和表名没有规定，可任意取名，只要方便记忆即可。",
        "result": false
      },
      {
        "title": "库名应该尽量与应用名称保持一致，表的命名最好是业务名称_表名的方式。",
        "result": true
      },
      {
        "title": "无论是库名还是表名都禁用保留字，如desc、match、range等。",
        "result": true
      },
      {
        "title": "表名、字段名必须使用小写字母或数字。",
        "result": true
      }
    ]
  },
  {
    "id": 47,
    "title": "关于异常的处理方式，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "为防止obj对象本身空指针异常，书写代码时应该注意加异常捕获处理，例如：try { obj.method() } catch(NullPointerException e){⋯⋯} 。",
        "result": false
      },
      {
        "title": "方法签名中，抛给调用者的关键字为throws",
        "result": true
      },
      {
        "title": "方法内部，抛出异常实例对象为throws",
        "result": false
      },
      {
        "title": "自定义异常要做到“认知对等”，即：抛出者和接收者要保持对自定义异常的认知统一，接收方需要知道这种异常的含义和对应的处理方案。",
        "result": true
      }
    ]
  },
  {
    "id": 48,
    "title": "数组使用Arrays.asList转化为集合，下列说法哪些正确的",
    "multi": true,
    "choose": [
      {
        "title": "数组元素的修改，会影响到转化过来的集合。",
        "result": true
      },
      {
        "title": "数组元素的修改，不会影响到转化过来的集合。",
        "result": false
      },
      {
        "title": "对于转换过来的集合，它的 add/remove/clear 方法会抛出: UnsupportedOperationException。",
        "result": true
      },
      {
        "title": "Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。",
        "result": true
      }
    ]
  },
  {
    "id": 49,
    "title": "关于文件编码和格式的设定，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "IDE的text file encoding设置为GBK格式。",
        "result": false
      },
      {
        "title": "IDE的text file encoding设置为UTF-8格式。",
        "result": true
      },
      {
        "title": "IDE中文件的换行符使用unix格式。",
        "result": true
      },
      {
        "title": "IDE中文件的换行符使用windows格式。",
        "result": false
      }
    ]
  },
  {
    "id": 50,
    "title": "关于数据库是与否概念的列的命名方式，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "对于是与否概念的列名，必须使用can_abc 来表示。",
        "result": false
      },
      {
        "title": "对于是与否概念的列名，必须使用is_abc 来表示。",
        "result": true
      },
      {
        "title": "数据类型是varchar(1)（ Y表示是，N表示否）。",
        "result": false
      },
      {
        "title": "数据类型是unsigned tiny int.（ 1表示是，0表示否）。",
        "result": true
      }
    ]
  },
  {
    "id": 51,
    "title": "以下关于格式规约的说法，正确的有哪些",
    "multi": true,
    "choose": [
      {
        "title": "代码块缩进4个空格，如果使用tab缩进，请设置成1个tab为4个空格；",
        "result": true
      },
      {
        "title": "代码块缩进5个空格，如果使用tab缩进，请设置成1个tab为5个空格。",
        "result": false
      },
      {
        "title": "为了保持代码美观，《手册》强烈推荐增加若干空格，使某一行的变量与相邻对应位置的变量对齐。",
        "result": false
      },
      {
        "title": "方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间推荐插入一个空行；相同业务逻辑和语义之间不需要插入空行。",
        "result": true
      }
    ]
  },
  {
    "id": 52,
    "title": "通过集合A.subList()获取子集合B，下列说法哪些是正确的",
    "multi": true,
    "choose": [
      {
        "title": "返回的集合B没有实现Serializable接口，不能被序列化，所以不能应用于RPC场景。",
        "result": true
      },
      {
        "title": "在B集合中添加某个元素，那么A集合也会添加进去此元素。",
        "result": true
      },
      {
        "title": "集合A中元素的修改不会影响到集合B的任何操作。",
        "result": false
      },
      {
        "title": "对A元素个数的修改，会导致集合B的遍历产生ConcurrentModificationException 异常。",
        "result": true
      }
    ]
  },
  {
    "id": 53,
    "title": "关于捕获异常和抛异常，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "如果需要捕获不同类型异常，为了方便处理，可以使用catch(Exception e){...}。",
        "result": false
      },
      {
        "title": "不要捕获异常后不处理，丢弃异常信息。",
        "result": true
      },
      {
        "title": "捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。",
        "result": true
      },
      {
        "title": "异常定义时区分unchecked / checked 异常，避免直接使用RuntimeException抛出。",
        "result": true
      }
    ]
  },
  {
    "id": 54,
    "title": "关于线程安全，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "SimpleDateFormat 是线程不安全的类。",
        "result": true
      },
      {
        "title": "SimpleDateFormat 是线程安全的类。",
        "result": false
      },
      {
        "title": "一般不要定义SimpleDateFormat的static变量，如果定义为static，必须保证线程安全。",
        "result": true
      },
      {
        "title": "推荐使用Apache封装好的DateUtils和DateFormatUtils工具类，来处理时间日期转换问题。",
        "result": true
      }
    ]
  },
  {
    "id": 55,
    "title": "为了更方便地进行单元测试，被测试的业务代码应避免以下哪些情况？",
    "multi": true,
    "choose": [
      {
        "title": "构造方法中做的事情过多。",
        "result": true
      },
      {
        "title": "存在过多的全局变量和静态方法。",
        "result": true
      },
      {
        "title": "存在过多的外部依赖。",
        "result": true
      },
      {
        "title": "存在过多的条件语句。",
        "result": true
      }
    ]
  },
  {
    "id": 56,
    "title": "关于控制语句，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "推荐 if-else的方式可以改写成卫语句的形式。",
        "result": true
      },
      {
        "title": "尽量减少try-catch 块内的逻辑，定义对象、变量、获取数据库连接等操作可以移到try-catch块外处理",
        "result": true
      },
      {
        "title": "if ( condition) statements; 单行语句不需要使用大括号。",
        "result": false
      },
      {
        "title": "在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。",
        "result": true
      }
    ]
  },
  {
    "id": 57,
    "title": "关于参数有效性验证，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "防止page size过大导致内存溢出。",
        "result": true
      },
      {
        "title": "防止正则输入源串拒绝服务ReDOS。",
        "result": true
      },
      {
        "title": "防止任意重定向。",
        "result": true
      },
      {
        "title": "预防 SQL 注入。",
        "result": true
      }
    ]
  },
  {
    "id": 58,
    "title": "关于变量和常量定义，下列哪些符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "Long a=2L；//大写的L",
        "result": true
      },
      {
        "title": "Long a=2l; //小写的l",
        "result": false
      },
      {
        "title": "常量只定义一次，不再赋值，所以不需要命名规范。",
        "result": false
      },
      {
        "title": "不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。",
        "result": true
      }
    ]
  },
  {
    "id": 59,
    "title": "在定义DO/DTO/VO/等POJO类时，对属性默认值的设定，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": false,
    "choose": [
      {
        "title": "String类型的默认值设定为空字符串。",
        "result": false
      },
      {
        "title": "Date类型的默认值设定为new Date()。",
        "result": false
      },
      {
        "title": "集合类型的默认值设定为Collections.EMPTY_LIST。",
        "result": false
      },
      {
        "title": "不要设定任何属性默认值。",
        "result": true
      }
    ]
  },
  {
    "id": 60,
    "title": "关于二方库依赖的解析命令，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "mvn dependency:resolve 打印出已仲裁依赖的列表。",
        "result": true
      },
      {
        "title": "mvn dependency:tree 打印工程整个的依赖树结构。",
        "result": true
      },
      {
        "title": "mvn dependency:tree -Dverbose -Dincludes=commons-lang 打印出与commons-lang相关的详细依赖。",
        "result": true
      },
      {
        "title": "mvn clean install 打印工程整个的依赖树结构，并部署到本地仓库中。",
        "result": false
      }
    ]
  },
  {
    "id": 61,
    "title": "KV结构的集合，在处理null值的存储上有细微的区别，下列哪些说法是正确的",
    "multi": false,
    "choose": [
      {
        "title": "TreeMap的key不可以为null",
        "result": true
      },
      {
        "title": "TreeMap的key可以为null",
        "result": false
      },
      {
        "title": "ConcurrentHashMap的key可以为null",
        "result": false
      },
      {
        "title": "ConcurrentHashMap的value可以为null",
        "result": false
      }
    ]
  },
  {
    "id": 62,
    "title": "关于数据库中表相关的命名，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "表名、字段名禁止出现数字开头，禁止两个下划线中间只出现数字。",
        "result": true
      },
      {
        "title": "表名不使用复数名词。",
        "result": true
      },
      {
        "title": "表必备三字段命名：id, gmt_create, gmt_modify。",
        "result": false
      },
      {
        "title": "表必备三字段命名：id, gmt_create, gmt_modified。",
        "result": true
      }
    ]
  },
  {
    "id": 63,
    "title": "关于多线程并行处理定时任务的情况，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "推荐使用Timer方式处理。",
        "result": false
      },
      {
        "title": "推荐使用ScheduledExecutorService方式处理。",
        "result": true
      },
      {
        "title": "Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行。",
        "result": true
      },
      {
        "title": "ScheduledExecutorService并发运行多个定时任务时，其中某线程抛出异常，不会影响到其它线程的继续运行。",
        "result": true
      }
    ]
  },
  {
    "id": 64,
    "title": "关于Java代码的设计和开发注意事项，下列哪些说法符合《集合开发规约》",
    "multi": true,
    "choose": [
      {
        "title": "禁止将URL、文件名、系统参数、数据库连接地址、业务规则的可变参数，硬编码在工程中。",
        "result": true
      },
      {
        "title": "long或者Long初始赋值时，必须是大写的L，不能小写。",
        "result": true
      },
      {
        "title": "当一个类有多个构造方法，或是多个同名方法，这些方法应该按顺序放置在一起，便于阅读。",
        "result": true
      },
      {
        "title": "相同参数类型，同等业务含义，才可以使用Java的可变参数，参数的类型尽量避免使用Object。",
        "result": true
      }
    ]
  },
  {
    "id": 65,
    "title": "关于数据库索引的命名，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "主键索引(primary key)，字段类型为unsigned bigint、单表时推荐自增、步长为1。",
        "result": true
      },
      {
        "title": "主键索引(primary key)，字段类型为unsigned bigint、单表时推荐自增、步长为2。",
        "result": false
      },
      {
        "title": "唯一索引（unique key），命名规则为uk_字段名（如果多个字段继续下划线）。",
        "result": true
      },
      {
        "title": "普通索引(normal index)，标记成idx_字段名（如果多个继续下划线）。",
        "result": true
      }
    ]
  },
  {
    "id": 66,
    "title": "以下关于命名规约内容说明，正确的是",
    "multi": true,
    "choose": [
      {
        "title": "【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，并且使用复数形式，例如：应用工具类包名为 com.alibaba.mpp.utils。",
        "result": false
      },
      {
        "title": "【强制】类名使用 UpperCamelCase，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO/DTO/VO/DAO 等",
        "result": true
      },
      {
        "title": "【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。",
        "result": true
      },
      {
        "title": "【强制】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开",
        "result": false
      }
    ]
  },
  {
    "id": 67,
    "title": "关于客户数据展示，下列哪些说法符合《阿里巴巴 Java 开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "客户的密码，密钥及密保问题答案等信息禁止展示",
        "result": true
      },
      {
        "title": "客户的银行卡号只显示后四位",
        "result": true
      },
      {
        "title": "客户的证件号码只显示第一位和最后一位，在必要业务场景下，经多因子强验证后可完整显示。",
        "result": true
      },
      {
        "title": "涉及有完整展示客户信息的页面均需要接入防爬系统",
        "result": true
      }
    ]
  },
  {
    "id": 68,
    "title": "关于系统安全，下列哪些说法符合《阿里巴巴 Java 开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "非 SEO URL 必须配置为禁止爬虫访问。",
        "result": false
      },
      {
        "title": "用户生成内容的场景，如发帖评论等，必须实现防刷。",
        "result": true
      },
      {
        "title": "使用平台资源，比如短信、邮件等功能，避免被滥刷资损，同时防止对用户造成骚扰。",
        "result": true
      },
      {
        "title": "文本内容必须进行违禁词过滤。",
        "result": true
      }
    ]
  },
  {
    "id": 69,
    "title": "关于 hashcode 和 equals，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "hashcode 是 Class 的方法，equals 是 Object 的方法。",
        "result": false
      },
      {
        "title": "hashcode 决定（如：HashMap）存储位置；equals 决定是否需要覆盖（同一 hash 下）集合元素。",
        "result": true
      },
      {
        "title": "类重写 hashcode，必须重写 equals。",
        "result": true
      },
      {
        "title": "两者是否需要重写，没有必然联系。",
        "result": false
      }
    ]
  },
  {
    "id": 70,
    "title": "关于构造方法，下列哪些说法符合《阿里巴巴 Java 开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。",
        "result": true
      },
      {
        "title": "当一个类有多个构造方法，应该按顺序放置在一起，便于阅读。",
        "result": true
      },
      {
        "title": "如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。",
        "result": true
      },
      {
        "title": "构造方法中可以有业务实现代码，如对成员变量的简单运算、业务判断等。",
        "result": false
      }
    ]
  },
  {
    "id": 71,
    "title": "针对 tcp 协议，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "tcp 链接主动关闭的一方，在完成四次挥手协议后，即会立即关闭并释放 socket。",
        "result": false
      },
      {
        "title": "处于 time_wait 状态的 socket，其实是已经关闭状态，当需要新建连接时，可以被马上复用。",
        "result": false
      },
      {
        "title": "当大量 socket 处于 time_wait 状态时，会导致可用 socket 资源稀缺，从而导致服务器并发能力下降。",
        "result": true
      },
      {
        "title": "通过修改/etc/sysctl.conf配置文件，减少 time_wait 的超时时间，可以降低 time_wait 状态的 socket 数量，从而提升服务器并发能力。",
        "result": true
      }
    ]
  },
  {
    "id": 72,
    "title": "关于应用与数据库之间的操作，下列哪些说法符合《阿里巴巴 Java 开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "对外提供一个大而全的接口进行 POJO 的 update 更新，这样比较省事、省代码。",
        "result": false
      },
      {
        "title": "使用事务回滚的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。",
        "result": true
      },
      {
        "title": "应用服务器与数据库之间是短连接。",
        "result": true
      },
      {
        "title": "应用服务器与数据库之间是长连接。",
        "result": false
      }
    ]
  },
  {
    "id": 73,
    "title": "关于异常处理，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "try 块放到了事务代码中，catch 异常后，如果需要回滚事务，必须要手动回滚事务。",
        "result": true
      },
      {
        "title": "在 finally 块必须对文件流进行关闭。",
        "result": true
      },
      {
        "title": "不能再 finally 块使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。",
        "result": true
      },
      {
        "title": "循环体中避免不需要的 try-catch 操作。",
        "result": true
      }
    ]
  },
  {
    "id": 74,
    "title": "关于应用中可以直接依赖的日志框架，下列哪些说法符合《阿里巴巴 Java 开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "Log4j",
        "result": false
      },
      {
        "title": "SLF4J",
        "result": true
      },
      {
        "title": "JCL(Jakarta Commons Logging)。",
        "result": true
      },
      {
        "title": "Logback。",
        "result": false
      }
    ]
  },
  {
    "id": 75,
    "title": "关于类和方法的命名，下列哪些说法符合《阿里巴巴 Java 开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "类名使用 UpperCamelCase 命名法，但是领域模型命名除外，如：ProductDO 的命名是规范的。",
        "result": true
      },
      {
        "title": "方法名命名应用使用 lowerCamelCase 命名法，如方法名：getHttpMessage() 是符合命名规范的。",
        "result": true
      },
      {
        "title": "为了方便理解，方法名或参数名可以使用拼音与英文混合的方式。",
        "result": false
      },
      {
        "title": "所有编程相关的命名均不能以下划线或美元符号开始，也不能以下划线或美元符合结束。",
        "result": true
      }
    ]
  },
  {
    "id": 76,
    "title": "关于二方库的依赖处理，下列哪些说法符合《阿里巴巴 Java 开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "依赖于一个二方库群时，必须定义一个统一版本变量，避免各子二方库版本号不一致。",
        "result": true
      },
      {
        "title": "可以允许子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的 Version。",
        "result": false
      },
      {
        "title": "所有 pom 文件中的依赖声明放在 <dependencies> 语句块中，所有版本仲裁放在 <dependencyManagement> 语句块中。",
        "result": true
      },
      {
        "title": "线上应用不要依赖 SNAPSHOT 版本（安全包除外）",
        "result": true
      }
    ]
  },
  {
    "id": 77,
    "title": "关于方法的返回值是否可以为null，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "方法的返回值可以为null，如果是集合，必须返回空集合。",
        "result": false
      },
      {
        "title": "方法的返回值可以为null，不强制返回空集合，或者空对象等。",
        "result": true
      },
      {
        "title": "方法实现者必须添加注释，充分说明什么情况下会返回null值。",
        "result": true
      },
      {
        "title": "防止NPE是调用者的责任。",
        "result": true
      }
    ]
  },
  {
    "id": 78,
    "title": "关于领域模型命名，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "数据对象命名：xxxDO，xxx即为数据表名，例如：ResellerAccountDO。",
        "result": true
      },
      {
        "title": "数据传输对象：xxxDTO，xxx为业务领域相关的名称，例如ProductDTO。",
        "result": true
      },
      {
        "title": "展示层对象：xxxVO，xxx一般为网页名称，例如RecommendProductVO。",
        "result": true
      },
      {
        "title": "POJO是DO/DTO/BO/VO的统称，命名成xxxPOJO。",
        "result": true
      }
    ]
  },
  {
    "id": 79,
    "title": "关于建表规约，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "字段为非负数，必须定义为unsigned。",
        "result": true
      },
      {
        "title": "存储的字符数几乎完全相等的字段，推荐定义为char类型存储。",
        "result": true
      },
      {
        "title": "varchar会预先分配存储空间。",
        "result": false
      },
      {
        "title": "不得使用级联与外键，一切外键概念必须在应用层解决。",
        "result": true
      }
    ]
  },
  {
    "id": 80,
    "title": "使用CountDownLatch进行异步转同步操作时，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "每个线程退出前必须调用countDown()方法。",
        "result": true
      },
      {
        "title": "线程执行代码注意catch异常，确保countDowm()方法可以被执行。",
        "result": true
      },
      {
        "title": "子线程抛出异常堆钱，直接就可以在主线程catch到。",
        "result": false
      },
      {
        "title": "主线程必须在启动其他线程后调用await()方法，这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。",
        "result": true
      }
    ]
  },
  {
    "id": 81,
    "title": "关于二方库GroupID和ArtifactID格式，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "GroupID格式为：com.{公司/子公司}.业务线[.子业务]。",
        "result": true
      },
      {
        "title": "GroupID格式为：com.{公司/子公司}.业务线.子业务线.子模块。",
        "result": false
      },
      {
        "title": "ArtifactlD格式为：产品线名_模块名或者产品线.模块名。",
        "result": false
      },
      {
        "title": "ArtifactID格式为：产品线名-模块名。",
        "result": true
      }
    ]
  },
  {
    "id": 82,
    "title": "关于try-catch的使用方式，下列哪些说法是正确的",
    "multi": true,
    "choose": [
      {
        "title": "推荐用try-catch来做流程控制、条件控制。",
        "result": false
      },
      {
        "title": "捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。",
        "result": true
      },
      {
        "title": "对大段代码进行try-catch，利用Throwable来捕捉，万无一失。",
        "result": false
      },
      {
        "title": "对大段代码进行try-catch，这是不负责任的表现，分清稳定代码和非稳定代码，对非稳定的代码做对应的异常处理。",
        "result": true
      }
    ]
  },
  {
    "id": 83,
    "title": "关于join的描述，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "join的字段，数据类型须保持绝对一致。",
        "result": true
      },
      {
        "title": "join列必须有索引。",
        "result": true
      },
      {
        "title": "优先where过滤，其次再join关联。",
        "result": true
      },
      {
        "title": "只要满足业务需求和，join表的个数不受限制。",
        "result": false
      }
    ]
  },
  {
    "id": 84,
    "title": "关于数据库查询的描述，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "当需要获取数据表所有字段的值映射到DO时，可使用select *来查询。",
        "result": false
      },
      {
        "title": "绝对禁止左模糊和全模糊查询；限制使用右模糊查询。全模糊或左模糊搜索的需求走搜索引擎实现。",
        "result": true
      },
      {
        "title": "禁止使用存储过程来查询返回数据。",
        "result": true
      },
      {
        "title": "在表查询中，需order by排序时，优先使用主键列，索引列。",
        "result": true
      }
    ]
  },
  {
    "id": 85,
    "title": "关于ORM的规则，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "数据库中，表达是与否概念的字段，必须使用is_xxx的方式命名。",
        "result": true
      },
      {
        "title": "推荐使用iBATIS自带的queryForList(String statementName, int start, int size)进行分页查询。",
        "result": false
      },
      {
        "title": "为避免写resultMap，可以直接拿HashMap与HashTable作为查询结果集的输出。",
        "result": false
      },
      {
        "title": "不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义。",
        "result": true
      }
    ]
  },
  {
    "id": 86,
    "title": "关于基本数据类型与包装数据类型的使用标准，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "所有的POJO类属性必须使用包装数据类型。",
        "result": true
      },
      {
        "title": "RPC方法的返回值和参数必须使用包装数据类型。",
        "result": true
      },
      {
        "title": "因为JAVA的自动装箱与拆箱机制，不需要根据场景来区分数据类型。",
        "result": false
      },
      {
        "title": "所有的局部变量推荐使用基本数据类型。",
        "result": true
      }
    ]
  },
  {
    "id": 87,
    "title": "在《阿里巴巴Java开发手册》中，提到不要对单元测试存在哪些误解？",
    "multi": true,
    "choose": [
      {
        "title": "那是测试同学干的事情。",
        "result": true
      },
      {
        "title": "单元测试代码是多余的。",
        "result": true
      },
      {
        "title": "单元测试代码不需要维护。",
        "result": true
      },
      {
        "title": "单元测试与线上故障没有辩证关系。",
        "result": true
      }
    ]
  },
  {
    "id": 88,
    "title": "关于使用iBATIS操作数据，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "如果表中字段和DO中的字段名完全一致，可直接用DO作为resultClass。",
        "result": false
      },
      {
        "title": "iBATIS中自带了queryForList(String statementName, int start, int size)的分页接口，可直接使用，无需再自行封装。",
        "result": false
      },
      {
        "title": "不要定义大而全的数据更新接口，对整个DO进行更新。必须按需更新。",
        "result": true
      },
      {
        "title": "sqlmap中写update语句时，必须包含对记录中gmt_modified字段的更新。",
        "result": true
      }
    ]
  },
  {
    "id": 89,
    "title": "关于注释，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "方法头定义签名上的注释可以使用//（双划线）简单说明，不必要遵守javadoc规范。",
        "result": false
      },
      {
        "title": "类定义开始部分，一般都用javadoc注释程序的总体描述以及作者信息。",
        "result": true
      },
      {
        "title": "方法头定义签名上的注释必须遵守javadoc规范，使用/**回车来生成，不得在方法定义上方使用//（双划线）简单说明。",
        "result": true
      },
      {
        "title": "方法头定义签名上的注释，可以使用// XXX的形式",
        "result": false
      }
    ]
  },
  {
    "id": 90,
    "title": "关于注释，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "方法内部单行注释，在被注释语句上方另起一行，使用//注释。",
        "result": true
      },
      {
        "title": "所有的类都必须添加创建者信息。",
        "result": true
      },
      {
        "title": "相比较使用“半吊子”英文来注释，用中文注释把问题说清楚更合适。",
        "result": true
      },
      {
        "title": "所有的枚举类型字段必须要有注释，说明每个数据项的用途。",
        "result": true
      }
    ]
  },
  {
    "id": 91,
    "title": "关于二方库使用枚举类型，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "二方库里可以定义枚举类型。",
        "result": true
      },
      {
        "title": "二方库里接口的入参可以使用枚举类型。",
        "result": true
      },
      {
        "title": "二方库里接口的返回值不能使用枚举类型，但可以包含枚举类型。",
        "result": false
      },
      {
        "title": "二方库里接口的返回值是枚举类型或包含枚举类型时，当二方库的枚举值升级（增加枚举值）时，可能会导致接口调用时出现枚举对象序列化异常。",
        "result": true
      }
    ]
  },
  {
    "id": 92,
    "title": "关于日志的打印，下列哪些写法符合《阿里巴巴Java开发手册》",
    "multi": false,
    "choose": [
      {
        "title": "System.out(\"xxx\"+e.getMessage())。",
        "result": false
      },
      {
        "title": "System.err(\"xxx\"+e.getMessage())。",
        "result": false
      },
      {
        "title": "e.printStackTrace()。",
        "result": false
      },
      {
        "title": "logger.error(\"exception happens product info:\" + product.toString() + \"_\" + e.getMessage() e)。",
        "result": true
      }
    ]
  },
  {
    "id": 93,
    "title": "单元测试代码写在Java工程的哪个地方最为合适？",
    "multi": false,
    "choose": [
      {
        "title": "写在业务代码体里边，方便调试。",
        "result": false
      },
      {
        "title": "写在业务代码同一个包下，方便归类查找。",
        "result": false
      },
      {
        "title": "写在src/test/java目录下。",
        "result": true
      },
      {
        "title": "写在src/java目录下。",
        "result": false
      }
    ]
  },
  {
    "id": 94,
    "title": "关于系统安全，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "表单、AJAX提交不需要进行CSRF安全过滤。",
        "result": false
      },
      {
        "title": "表单、AJAX提交必须执行CSRF安全过滤。",
        "result": true
      },
      {
        "title": "URL外部重定向传入的目标地址必须执行白名单过滤。",
        "result": true
      },
      {
        "title": "用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，禁止字符串拼接SQL访问数据库。",
        "result": true
      }
    ]
  },
  {
    "id": 95,
    "title": "关于组合索引，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "查询条件where a='0' and b='1'，当组合索引为(b, a)的时候能进行索引扫描。",
        "result": true
      },
      {
        "title": "查询条件where a='0' and b='1'，当组合索引为(c, a, b)的时候能进行索引扫描。",
        "result": false
      },
      {
        "title": "查询select b from table where a='0'，当组合索引为(a, b)的时候会进行索引扫描。",
        "result": true
      },
      {
        "title": "查询条件where a>0 order by b，当组合索引为(a, b)时会利用索引进行排序。",
        "result": false
      }
    ]
  },
  {
    "id": 96,
    "title": "关于Java代码的设计和开发注意事项，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "所有的覆写方法，必须是强制加@Override。",
        "result": true
      },
      {
        "title": "setter方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。",
        "result": true
      },
      {
        "title": "在getter方法中，尽量不要增加逻辑判断，因为添加了逻辑判断后，会增加排查问题难度。",
        "result": true
      },
      {
        "title": "避免用BeanUtil进行属性的copy。",
        "result": true
      }
    ]
  },
  {
    "id": 97,
    "title": "关于常量定义，下列哪些说法符合《阿里巴巴Java开发手册》",
    "multi": true,
    "choose": [
      {
        "title": "跨应用共享常量：放置在二方库中，通常是client.jar中的const目录下。",
        "result": true
      },
      {
        "title": "应用内共享常量：通常放置在一方库的modules中的const目录下。",
        "result": true
      },
      {
        "title": "子工程内部共享常量：即在当前子工程的const目录下。",
        "result": true
      },
      {
        "title": "类内常量：直接在类内部private static final定义。",
        "result": true
      }
    ]
  },
  {
    "id": 98,
    "title": "下面的例子代码和描述，哪些是有不正确的",
    "multi": true,
    "choose": [
      {
        "title": "单行字符数限制不超过140个，超出需要换行",
        "result": true
      },
      {
        "title": "IDE的text file encoding设置为GBK；IDE中文件的换行符使用Unix格式，不要使用windows格式。",
        "result": false
      },
      {
        "title": "大括号与if，else，for，do，while语句一起使用，即使只有一条语句（或是空），也应该把大括号写上。",
        "result": true
      },
      {
        "title": "大括号的使用约定。如果是大括号内为空，则简洁地写成即可，不需要换行。",
        "result": true
      }
    ]
  },
  {
    "id": 99,
    "title": "好的单元测试必须遵守AlR原则，那么AlR原则具体是指",
    "multi": true,
    "choose": [
      {
        "title": "单元测试应该是全自动执行的，并且非交互式的。",
        "result": true
      },
      {
        "title": "单元测试必须在线上环境能够全部被正确地编译。",
        "result": false
      },
      {
        "title": "为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。",
        "result": true
      },
      {
        "title": "单元测试是可以重复执行的。",
        "result": true
      }
    ]
  },
  {
    "id": 100,
    "title": "编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量，那么下列说法正确的是",
    "multi": true,
    "choose": [
      {
        "title": "Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。",
        "result": true
      },
      {
        "title": "Correct，正确的输入，并得到预期的结果。",
        "result": true
      },
      {
        "title": "Design，与设计文档相结合，来编写单元测试。",
        "result": true
      },
      {
        "title": "Equal，单元测试环境必须与线上生产环境一致。「ERROR」。",
        "result": false
      }
    ]
  }
]